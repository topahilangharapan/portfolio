"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTemplateCodegenContext = createTemplateCodegenContext;
const codeFeatures_1 = require("../codeFeatures");
const utils_1 = require("../utils");
function createTemplateCodegenContext(options) {
    let ignoredError = false;
    let expectErrorToken;
    let lastGenericComment;
    let variableId = 0;
    function resolveCodeFeatures(features) {
        if (features.verification) {
            if (ignoredError) {
                return {
                    ...features,
                    verification: false,
                };
            }
            if (expectErrorToken) {
                const token = expectErrorToken;
                return {
                    ...features,
                    verification: {
                        shouldReport: () => {
                            token.errors++;
                            return false;
                        },
                    },
                };
            }
        }
        return features;
    }
    const localVars = new Map();
    const specialVars = new Set();
    const accessExternalVariables = new Map();
    const slots = [];
    const dynamicSlots = [];
    const blockConditions = [];
    const scopedClasses = [];
    const emptyClassOffsets = [];
    const inlayHints = [];
    const bindingAttrLocs = [];
    const inheritedAttrVars = new Set();
    const templateRefs = new Map();
    return {
        codeFeatures: new Proxy(codeFeatures_1.codeFeatures, {
            get(target, key) {
                const data = target[key];
                return resolveCodeFeatures(data);
            },
        }),
        resolveCodeFeatures,
        slots,
        dynamicSlots,
        specialVars,
        accessExternalVariables,
        lastGenericComment,
        blockConditions,
        scopedClasses,
        emptyClassOffsets,
        inlayHints,
        hasSlot: false,
        bindingAttrLocs,
        inheritedAttrVars,
        templateRefs,
        currentComponent: undefined,
        singleRootElType: undefined,
        singleRootNode: undefined,
        accessExternalVariable(name, offset) {
            let arr = accessExternalVariables.get(name);
            if (!arr) {
                accessExternalVariables.set(name, arr = new Set());
            }
            if (offset !== undefined) {
                arr.add(offset);
            }
        },
        hasLocalVariable: (name) => {
            return !!localVars.get(name);
        },
        addLocalVariable: (name) => {
            localVars.set(name, (localVars.get(name) ?? 0) + 1);
        },
        removeLocalVariable: (name) => {
            localVars.set(name, localVars.get(name) - 1);
        },
        getInternalVariable: () => {
            return `__VLS_${variableId++}`;
        },
        ignoreError: function* () {
            if (!ignoredError) {
                ignoredError = true;
                yield `// @vue-ignore start${utils_1.newLine}`;
            }
        },
        expectError: function* (prevNode) {
            if (!expectErrorToken) {
                expectErrorToken = {
                    errors: 0,
                    node: prevNode,
                };
                yield `// @vue-expect-error start${utils_1.newLine}`;
            }
        },
        resetDirectiveComments: function* (endStr) {
            if (expectErrorToken) {
                const token = expectErrorToken;
                yield* (0, utils_1.wrapWith)(expectErrorToken.node.loc.start.offset, expectErrorToken.node.loc.end.offset, {
                    verification: {
                        shouldReport: () => token.errors === 0,
                    },
                }, `// @ts-expect-error __VLS_TS_EXPECT_ERROR`);
                yield `${utils_1.newLine}${utils_1.endOfLine}`;
                expectErrorToken = undefined;
                yield `// @vue-expect-error ${endStr}${utils_1.newLine}`;
            }
            if (ignoredError) {
                ignoredError = false;
                yield `// @vue-ignore ${endStr}${utils_1.newLine}`;
            }
        },
        generateAutoImportCompletion: function* () {
            if (!options.edited) {
                return;
            }
            const all = [...accessExternalVariables.entries()];
            if (!all.some(([_, offsets]) => offsets.size)) {
                return;
            }
            yield `// @ts-ignore${utils_1.newLine}`; // #2304
            yield `[`;
            for (const [varName, offsets] of all) {
                for (const offset of offsets) {
                    if (options.scriptSetupBindingNames.has(varName)) {
                        // #3409
                        yield [
                            varName,
                            'template',
                            offset,
                            {
                                ...codeFeatures_1.codeFeatures.additionalCompletion,
                                ...codeFeatures_1.codeFeatures.withoutHighlightAndCompletionAndNavigation,
                            },
                        ];
                    }
                    else {
                        yield [
                            varName,
                            'template',
                            offset,
                            codeFeatures_1.codeFeatures.additionalCompletion,
                        ];
                    }
                    yield `,`;
                }
                offsets.clear();
            }
            yield `]${utils_1.endOfLine}`;
        }
    };
}
//# sourceMappingURL=context.js.map