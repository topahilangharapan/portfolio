"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComponent = generateComponent;
exports.generateElement = generateElement;
const CompilerDOM = require("@vue/compiler-dom");
const shared_1 = require("@vue/shared");
const shared_2 = require("../../utils/shared");
const inlayHints_1 = require("../inlayHints");
const utils_1 = require("../utils");
const camelized_1 = require("../utils/camelized");
const elementChildren_1 = require("./elementChildren");
const elementDirectives_1 = require("./elementDirectives");
const elementEvents_1 = require("./elementEvents");
const elementProps_1 = require("./elementProps");
const interpolation_1 = require("./interpolation");
const propertyAccess_1 = require("./propertyAccess");
const styleScopedClasses_1 = require("./styleScopedClasses");
const vSlot_1 = require("./vSlot");
const colonReg = /:/g;
function* generateComponent(options, ctx, node) {
    const tagOffsets = [node.loc.start.offset + options.template.content.slice(node.loc.start.offset).indexOf(node.tag)];
    if (!node.isSelfClosing && options.template.lang === 'html') {
        const endTagOffset = node.loc.start.offset + node.loc.source.lastIndexOf(node.tag);
        if (endTagOffset > tagOffsets[0]) {
            tagOffsets.push(endTagOffset);
        }
    }
    const failedPropExps = [];
    const possibleOriginalNames = getPossibleOriginalComponentNames(node.tag, true);
    const matchImportName = possibleOriginalNames.find(name => options.scriptSetupImportComponentNames.has(name));
    const var_originalComponent = matchImportName ?? ctx.getInternalVariable();
    const var_functionalComponent = ctx.getInternalVariable();
    const var_componentInstance = ctx.getInternalVariable();
    const var_componentEmit = ctx.getInternalVariable();
    const var_componentEvents = ctx.getInternalVariable();
    const var_defineComponentCtx = ctx.getInternalVariable();
    const isComponentTag = node.tag.toLowerCase() === 'component';
    ctx.currentComponent = {
        ctxVar: var_defineComponentCtx,
        used: false
    };
    let props = node.props;
    let dynamicTagInfo;
    if (isComponentTag) {
        for (const prop of node.props) {
            if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE
                && prop.name === 'bind'
                && prop.arg?.loc.source === 'is'
                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                if (prop.arg.loc.end.offset === prop.exp.loc.end.offset) {
                    ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.exp.loc, 'is'));
                }
                dynamicTagInfo = {
                    tag: prop.exp.content,
                    offsets: [prop.exp.loc.start.offset],
                    astHolder: prop.exp.loc,
                };
                props = props.filter(p => p !== prop);
                break;
            }
        }
    }
    else if (node.tag.includes('.')) {
        // namespace tag
        dynamicTagInfo = {
            tag: node.tag,
            offsets: tagOffsets,
            astHolder: node.loc,
        };
    }
    if (matchImportName) {
        // hover, renaming / find references support
        yield `// @ts-ignore${utils_1.newLine}`; // #2304
        yield `/** @type { [`;
        for (const tagOffset of tagOffsets) {
            yield `typeof `;
            if (var_originalComponent === node.tag) {
                yield [
                    var_originalComponent,
                    'template',
                    tagOffset,
                    ctx.codeFeatures.withoutHighlightAndCompletion,
                ];
            }
            else {
                const shouldCapitalize = matchImportName[0].toUpperCase() === matchImportName[0];
                yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node.tag) : node.tag, tagOffset, {
                    ...ctx.codeFeatures.withoutHighlightAndCompletion,
                    navigation: {
                        resolveRenameNewName: camelizeComponentName,
                        resolveRenameEditText: getTagRenameApply(node.tag),
                    },
                });
            }
            yield `, `;
        }
        yield `] } */${utils_1.endOfLine}`;
    }
    else if (dynamicTagInfo) {
        yield `const ${var_originalComponent} = (`;
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, 'template', ctx.codeFeatures.all, dynamicTagInfo.tag, dynamicTagInfo.offsets[0], dynamicTagInfo.astHolder, '(', ')');
        if (dynamicTagInfo.offsets[1] !== undefined) {
            yield `,`;
            yield* (0, interpolation_1.generateInterpolation)(options, ctx, 'template', ctx.codeFeatures.withoutCompletion, dynamicTagInfo.tag, dynamicTagInfo.offsets[1], dynamicTagInfo.astHolder, '(', ')');
        }
        yield `)${utils_1.endOfLine}`;
    }
    else if (!isComponentTag) {
        yield `const ${var_originalComponent} = ({} as __VLS_WithComponent<'${getCanonicalComponentName(node.tag)}', __VLS_LocalComponents, `;
        if (options.selfComponentName && possibleOriginalNames.includes(options.selfComponentName)) {
            yield `typeof __VLS_self & (new () => { `
                + (0, shared_2.getSlotsPropertyName)(options.vueCompilerOptions.target)
                + `: __VLS_Slots }), `;
        }
        else {
            yield `void, `;
        }
        yield getPossibleOriginalComponentNames(node.tag, false)
            .map(name => `'${name}'`)
            .join(`, `);
        yield `>).`;
        yield* generateCanonicalComponentName(node.tag, tagOffsets[0], ctx.codeFeatures.withoutHighlightAndCompletionAndNavigation);
        yield `${utils_1.endOfLine}`;
        const camelizedTag = (0, shared_1.camelize)(node.tag);
        if (utils_1.variableNameRegex.test(camelizedTag)) {
            // renaming / find references support
            yield `/** @type { [`;
            for (const tagOffset of tagOffsets) {
                for (const shouldCapitalize of (node.tag[0] === node.tag[0].toUpperCase() ? [false] : [true, false])) {
                    const expectName = shouldCapitalize ? (0, shared_1.capitalize)(camelizedTag) : camelizedTag;
                    yield `typeof __VLS_components.`;
                    yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node.tag) : node.tag, tagOffset, {
                        navigation: {
                            resolveRenameNewName: node.tag !== expectName ? camelizeComponentName : undefined,
                            resolveRenameEditText: getTagRenameApply(node.tag),
                        },
                    });
                    yield `, `;
                }
            }
            yield `] } */${utils_1.endOfLine}`;
            // auto import support
            if (options.edited) {
                yield `// @ts-ignore${utils_1.newLine}`; // #2304
                yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node.tag), tagOffsets[0], {
                    completion: {
                        isAdditional: true,
                        onlyImport: true,
                    },
                });
                yield `${utils_1.endOfLine}`;
            }
        }
    }
    else {
        yield `const ${var_originalComponent} = {} as any${utils_1.endOfLine}`;
    }
    yield `// @ts-ignore${utils_1.newLine}`;
    yield `const ${var_functionalComponent} = __VLS_asFunctionalComponent(${var_originalComponent}, new ${var_originalComponent}({${utils_1.newLine}`;
    yield* (0, elementProps_1.generateElementProps)(options, ctx, node, props, options.vueCompilerOptions.checkUnknownProps, false);
    yield `}))${utils_1.endOfLine}`;
    yield `const `;
    yield* (0, utils_1.wrapWith)(node.loc.start.offset, node.loc.end.offset, ctx.resolveCodeFeatures({
        verification: {
            shouldReport(_source, code) {
                return String(code) !== '6133';
            },
        }
    }), var_componentInstance);
    yield ` = ${var_functionalComponent}`;
    yield* generateComponentGeneric(ctx);
    yield `(`;
    yield* (0, utils_1.wrapWith)(tagOffsets[0], tagOffsets[0] + node.tag.length, ctx.codeFeatures.verification, `{${utils_1.newLine}`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, props, options.vueCompilerOptions.checkUnknownProps, true, failedPropExps), `}`);
    yield `, ...__VLS_functionalComponentArgsRest(${var_functionalComponent}))${utils_1.endOfLine}`;
    yield* generateFailedPropExps(options, ctx, failedPropExps);
    const [refName, offset] = yield* generateVScope(options, ctx, node, props);
    const isRootNode = node === ctx.singleRootNode;
    if (refName || isRootNode) {
        const varName = ctx.getInternalVariable();
        ctx.currentComponent.used = true;
        yield `var ${varName} = {} as (Parameters<NonNullable<typeof ${var_defineComponentCtx}['expose']>>[0] | null)`;
        if (node.codegenNode?.type === CompilerDOM.NodeTypes.VNODE_CALL
            && node.codegenNode.props?.type === CompilerDOM.NodeTypes.JS_OBJECT_EXPRESSION
            && node.codegenNode.props.properties.some(({ key }) => key.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && key.content === 'ref_for')) {
            yield `[]`;
        }
        yield `${utils_1.endOfLine}`;
        if (refName) {
            ctx.templateRefs.set(refName, [varName, offset]);
        }
        if (isRootNode) {
            ctx.singleRootElType = `NonNullable<typeof ${varName}>['$el']`;
        }
    }
    const usedComponentEventsVar = yield* (0, elementEvents_1.generateElementEvents)(options, ctx, node, var_functionalComponent, var_componentInstance, var_componentEvents);
    if (usedComponentEventsVar) {
        ctx.currentComponent.used = true;
        yield `let ${var_componentEmit}!: typeof ${var_defineComponentCtx}.emit${utils_1.endOfLine}`;
        yield `let ${var_componentEvents}!: __VLS_NormalizeEmits<typeof ${var_componentEmit}>${utils_1.endOfLine}`;
    }
    if (hasVBindAttrs(options, ctx, node)) {
        const attrsVar = ctx.getInternalVariable();
        ctx.inheritedAttrVars.add(attrsVar);
        yield `let ${attrsVar}!: Parameters<typeof ${var_functionalComponent}>[0];\n`;
    }
    const slotDir = node.props.find(p => p.type === CompilerDOM.NodeTypes.DIRECTIVE && p.name === 'slot');
    if (slotDir) {
        yield* (0, vSlot_1.generateVSlot)(options, ctx, node, slotDir);
    }
    else {
        yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node, true);
    }
    if (ctx.currentComponent.used) {
        yield `var ${var_defineComponentCtx}!: __VLS_PickFunctionalComponentCtx<typeof ${var_originalComponent}, typeof ${var_componentInstance}>${utils_1.endOfLine}`;
    }
}
function* generateElement(options, ctx, node, isVForChild) {
    const startTagOffset = node.loc.start.offset + options.template.content.slice(node.loc.start.offset).indexOf(node.tag);
    const endTagOffset = !node.isSelfClosing && options.template.lang === 'html'
        ? node.loc.start.offset + node.loc.source.lastIndexOf(node.tag)
        : undefined;
    const failedPropExps = [];
    yield `__VLS_asFunctionalElement(__VLS_intrinsicElements`;
    yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, startTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);
    if (endTagOffset !== undefined) {
        yield `, __VLS_intrinsicElements`;
        yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, endTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);
    }
    yield `)(`;
    yield* (0, utils_1.wrapWith)(startTagOffset, startTagOffset + node.tag.length, ctx.codeFeatures.verification, `{${utils_1.newLine}`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, node.props, options.vueCompilerOptions.checkUnknownProps, true, failedPropExps), `}`);
    yield `)${utils_1.endOfLine}`;
    yield* generateFailedPropExps(options, ctx, failedPropExps);
    const [refName, offset] = yield* generateVScope(options, ctx, node, node.props);
    if (refName) {
        let refValue = `__VLS_nativeElements['${node.tag}']`;
        if (isVForChild) {
            refValue = `[${refValue}]`;
        }
        ctx.templateRefs.set(refName, [refValue, offset]);
    }
    if (ctx.singleRootNode === node) {
        ctx.singleRootElType = `typeof __VLS_nativeElements['${node.tag}']`;
    }
    if (hasVBindAttrs(options, ctx, node)) {
        ctx.inheritedAttrVars.add(`__VLS_intrinsicElements.${node.tag}`);
    }
    yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node);
}
function* generateFailedPropExps(options, ctx, failedPropExps) {
    for (const failedExp of failedPropExps) {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, 'template', ctx.codeFeatures.all, failedExp.node.loc.source, failedExp.node.loc.start.offset, failedExp.node.loc, failedExp.prefix, failedExp.suffix);
        yield utils_1.endOfLine;
    }
}
function* generateVScope(options, ctx, node, props) {
    const vScope = props.find(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && (prop.name === 'scope' || prop.name === 'data'));
    let inScope = false;
    let originalConditionsNum = ctx.blockConditions.length;
    if (vScope?.type === CompilerDOM.NodeTypes.DIRECTIVE && vScope.exp) {
        const scopeVar = ctx.getInternalVariable();
        const condition = `__VLS_withScope(__VLS_ctx, ${scopeVar})`;
        yield `const ${scopeVar} = `;
        yield [
            vScope.exp.loc.source,
            'template',
            vScope.exp.loc.start.offset,
            ctx.codeFeatures.all,
        ];
        yield utils_1.endOfLine;
        yield `if (${condition}) {${utils_1.newLine}`;
        ctx.blockConditions.push(condition);
        inScope = true;
    }
    yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);
    const [refName, offset] = yield* generateReferencesForElements(options, ctx, node); // <el ref="foo" />
    (0, styleScopedClasses_1.collectStyleScopedClassReferences)(options, ctx, node);
    if (inScope) {
        yield `}${utils_1.newLine}`;
        ctx.blockConditions.length = originalConditionsNum;
    }
    return [refName, offset];
}
function getCanonicalComponentName(tagText) {
    return utils_1.variableNameRegex.test(tagText)
        ? tagText
        : (0, shared_1.capitalize)((0, shared_1.camelize)(tagText.replace(colonReg, '-')));
}
function getPossibleOriginalComponentNames(tagText, deduplicate) {
    const name1 = (0, shared_1.capitalize)((0, shared_1.camelize)(tagText));
    const name2 = (0, shared_1.camelize)(tagText);
    const name3 = tagText;
    const names = [name1];
    if (!deduplicate || name2 !== name1) {
        names.push(name2);
    }
    if (!deduplicate || name3 !== name2) {
        names.push(name3);
    }
    return names;
}
function* generateCanonicalComponentName(tagText, offset, features) {
    if (utils_1.variableNameRegex.test(tagText)) {
        yield [tagText, 'template', offset, features];
    }
    else {
        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(tagText.replace(colonReg, '-')), offset, features);
    }
}
function* generateComponentGeneric(ctx) {
    if (ctx.lastGenericComment) {
        const { content, offset } = ctx.lastGenericComment;
        yield* (0, utils_1.wrapWith)(offset, offset + content.length, ctx.codeFeatures.verification, `<`, [
            content,
            'template',
            offset,
            ctx.codeFeatures.all
        ], `>`);
    }
    ctx.lastGenericComment = undefined;
}
function* generateReferencesForElements(options, ctx, node) {
    for (const prop of node.props) {
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE
            && prop.name === 'ref'
            && prop.value) {
            const [content, startOffset] = (0, utils_1.normalizeAttributeValue)(prop.value);
            yield `// @ts-ignore navigation for \`const ${content} = ref()\`${utils_1.newLine}`;
            yield `/** @type { typeof __VLS_ctx`;
            yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, content, startOffset, ctx.codeFeatures.navigation, prop.value.loc);
            yield ` } */${utils_1.endOfLine}`;
            if (utils_1.variableNameRegex.test(content) && !options.templateRefNames.has(content)) {
                ctx.accessExternalVariable(content, startOffset);
            }
            return [content, startOffset];
        }
    }
    return [];
}
function hasVBindAttrs(options, ctx, node) {
    return options.vueCompilerOptions.fallthroughAttributes && (node === ctx.singleRootNode ||
        node.props.some(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE
            && prop.name === 'bind'
            && prop.exp?.loc.source === '$attrs'));
}
function camelizeComponentName(newName) {
    return (0, shared_1.camelize)('-' + newName);
}
function getTagRenameApply(oldName) {
    return oldName === (0, shared_2.hyphenateTag)(oldName) ? shared_2.hyphenateTag : undefined;
}
//# sourceMappingURL=element.js.map